;;;; see https://github.com/xysun/regex
;;;; this may not work

(defstruct token
  (name "char" :type string)
  (value #\] :type character))

(defun lexer (str)
  (let ((cur-pos 0)
        (str-len (length str))
        ;;(source str)
        (key-hash (make-hash-table)))
    (setf (gethash #\[ key-hash) "left[")
    (setf (gethash #\] key-hash) "right]")
    (setf (gethash #\+ key-hash) "one-or-more")
    (setf (gethash #\* key-hash) "zero-or-more")
    (setf (gethash #\| key-hash) "or")
    (setf (gethash #\? key-hash) "zero-or-one")
    (flet ((get-token ()
                      (if (>= cur-pos str-len)
                        (make-token :name "end")
                        (let ((cur-char (char str cur-pos)))
                          (incf cur-pos)
                          (multiple-value-bind (val find-p) (gethash cur-char key-hash)
                            (if find-p
                              (make-token :name val :value cur-char)
                              (make-token :value cur-char)))))))
      #'get-token)))

(defun parser (lexer-instance)
  (let ((tokens nil)
        (lookahead (funcall lexer-instance)))
    (labels ((parse-top ()
                        (parse-exp)
                        (nreverse tokens))
             (consume (name)
                      (if (string= name (token-name lookahead))
                        (setf lookahead (funcall lexer-instance))
                        (error "parse error")))
             (parse-exp ()
                        (parse-term)
                        (when (string= "or" (token-name lookahead))
                          (let ((old-look lookahead))
                            (consume "or")
                            (parse-exp)
                            (push old-look tokens))))
             (parse-term ()
                         (parse-factor)
                         (when (not (find (token-value lookahead) '(#\] #\|)))
                           (parse-term)
                           (push (make-token :name "concat") tokens)))
             (parse-factor ()
                           (parse-primary)
                           (when (find (token-value lookahead) '(#\* #\+ #\?))
                             (push lookahead tokens)
                             (consume (token-name lookahead))))
             (parse-primary ()
                            (let ((name (token-name lookahead)))
                              (cond ((string= name "left[")
                                     (consume "left[")
                                     (parse-exp)
                                     (consume "right]"))
                                    ((string= name "char")
                                     (push lookahead tokens)
                                     (consume "char"))))))
      (parse-top))))

(defstruct state
  (closure nil)
  (transitions (make-hash-table))
  (name nil) 
  (end-p nil))

(defstruct NFA
  start
  end)
(defun add-state (state state-set)
  (when (not (find state state-set))
    (pushnew state state-set)
    (mapc #'(lambda (x) (setf state-set (add-state x state-set)))
          (state-closure state)))
  state-set)
(defun match (nfa s)
  (let ((cur-states nil))
    (setf cur-states (add-state (NFA-start nfa) cur-states))
    (mapc #'(lambda (x) (let ((next-state nil))
                          (mapc #'(lambda (st)
                                    (when (gethash x (state-transitions st))
                                      (setf next-state (add-state (gethash x (state-transitions st)) next-state))))
                                cur-states)
                          (setf cur-states next-state)
                          ))
          (coerce s 'list))
    (mapc #'(lambda (st) (if (state-end-p st) (return-from match t)))
          cur-states))
  nil)

(let ((state-count -1))
  (defun create-state ()
    (incf state-count)
    (make-state :name state-count)))


(defun re-compile (pattern)
  (let ((lex (lexer pattern))
        tokens
        (handles (make-hash-table :test #'equal))
        (nfa-stack nil))
    (labels (
             (handle-char (tok)
                          (let ((s0 (create-state))
                                (s1 (create-state)))
                            (setf (gethash (token-value tok) (state-transitions s0)) s1)
                            (setf (state-end-p s1) t)
                            (push (make-NFA :start s0 :end s1) nfa-stack)))

             (handle-concat (tok)
                            (declare (ignore tok))
                            (let ((n2 (car nfa-stack))
                                  (n1 (cadr nfa-stack)))
                              (setf nfa-stack (cddr nfa-stack))
                              (setf (state-end-p (NFA-end n1)) nil)
                              (push (NFA-start n2) (state-closure (NFA-end n1)))
                              (setf (state-end-p (NFA-end n2)) t)
                              (push (make-NFA :start (NFA-start n1) :end (NFA-end n2)) nfa-stack)))

             (handle-or (tok)
                        (declare (ignore tok))
                        (let ((n2 (car nfa-stack))
                              (n1 (cadr nfa-stack))
                              (s0 (create-state))
                              (s3 (create-state)))
                          (setf nfa-stack (cddr nfa-stack))
                          (setf (state-closure s0) (list (NFA-start n1) (NFA-start n2)))
                          (push s3 (state-closure (NFA-end n1)))
                          (push s3 (state-closure (NFA-end n2)))
                          (setf (state-end-p (NFA-end n1)) nil)
                          (setf (state-end-p (NFA-end n2)) nil)
                          (setf (state-end-p s3) t)
                          (push (make-NFA :start s0 :end s3) nfa-stack)))

             (handle-rep (tok)
                         (let ((n1 (car nfa-stack))
                               (s0 (create-state))
                               (s1 (create-state)))
                           (setf nfa-stack (cdr nfa-stack))
                           (setf (state-closure s0) (list (NFA-start n1)))
                           (if (string= "zero-or-more" (token-name tok))
                             (push s1 (state-closure s0)))
                           (push s1 (state-closure (NFA-end n1)))
                           (push (NFA-start n1) (state-closure (NFA-end n1)))
                           (setf (state-end-p (NFA-end n1)) nil)
                           (setf (state-end-p s1) t)
                           (push (make-NFA :start s0 :end s1) nfa-stack)))

             (handle-? (tok)
                       (declare (ignore tok))
                       (let ((n1 (car nfa-stack)))
                         (setf nfa-stack (cdr nfa-stack))
                         (push (NFA-end n1) (state-closure (NFA-start n1)))
                         (push n1 nfa-stack))))
      (setf tokens (parser lex))
      (setf (gethash "char" handles) #'handle-char)
      (setf (gethash "concat" handles) #'handle-concat)
      (setf (gethash "or" handles) #'handle-or)
      (setf (gethash "zero-or-more" handles) #'handle-rep)
      (setf (gethash "one-or-more" handles) #'handle-rep)
      (setf (gethash "zero-or-one" handles) #'handle-?)
      (mapc #'(lambda (tok) (funcall (gethash (token-name tok) handles) tok))
            tokens)
      (if (and (null (cdr nfa-stack))
               (car nfa-stack))
        (car nfa-stack)
        (error "compile error")))))

(let ((pa "a?a?a?a?a?aaaaa")
      (str "aaaaa")
      nfa)
  (setf nfa (re-compile pa))
  (print (match nfa str)))
